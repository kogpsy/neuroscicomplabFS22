---
title: "√úbung 6"
description: |
  DDM Parameter sch√§tzen.
date: "2022-05-10"
author:
  - name: Andrew Ellis
    url: https://github.com/awellis
    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern
    affiliation-url: https://www.kog.psy.unibe.ch
    orcid: 0000-0002-2788-936X
license: CC BY
citation: true
bibliography: ../../bibliography.bib
format:
    html:
        toc: true
        code-link: true
---
```{r}
#| include: false

# Set working directory of R
knitr::opts_knit$set(root.dir = '../../data/exercise-06/data')
```

:::{.callout-note}
Die Daten f√ºr diese √úbung finden Sie hier: üëâ [Download Data](../../data/exercise-06/data/ddm-data.csv)

Die Aufgaben, die Sie bearbeiten sollen, finden Sie in einem gelben Kasten. Optionale Aufgaben sind in orangen K√§sten.

In diesem File finden Sie Beispielscode. Manche Zeilen enthalten `___`. Hier m√ºssen Sie den Code vervollst√§ndigen.

Laden Sie bitte Ihre L√∂sung als R Skript bis **Mittwoch, 17.5.2022, um 00:30 Uhr**, in den Order f√ºr √úbung 6 auf ILIAS.


Nennen Sie Ihr File *Matrikelnummer_Nachname_uebung-6.R*.
:::

# Aufgabenstellung

```{r}
#| include: false
#| eval: false
library(tidyverse)
library(rtdists)

true_params <- c(a = 1.0,
                 v1 = 0.3,
                 v2 = 1.2,
                 z = 0.5,
                 t0 = 0.2)

ntrials <- 1e3

make_subject <- function(ntrials = 1e3, pars, subject_no = 1) {

  a <- exp(log(pars["a"]) + rnorm(1, 0, 0.05))
  v1 <- exp(log(pars["v1"]) + rnorm(1, 0, 0.05))
  v2 <- exp(log(pars["v2"]) + rnorm(1, 0, 0.05))
  z <- plogis(qlogis(pars["z"]) + rnorm(1, 0, 0.05))
  t0 <- exp(log(pars["t0"]) + rnorm(1, 0, 0.05))

  s <- 1.0
  
  d <- as_tibble(bind_rows(
  rdiffusion(ntrials, a = a, v = v1, t0 = t0, z = z*a, s = s,
             sz = 0, sv = 0, d = 0) |>
  mutate(condition = "A",
         ID = subject_no),
  rdiffusion(ntrials, a = a, v = v2, t0 = t0, z = z*a, s = s,
             sz = 0, sv = 0, d = 0) |>
  mutate(condition = "B",
         ID = subject_no))) |>
  mutate(response = factor(response, levels = c("lower", "upper")),
         condition = as_factor(condition))
  d <- d |> mutate(a = a, v1 = v1, v2 = v2, z = z, t0 = t0)
}

nsubjects <- 12
set.seed(81)

d <- 1:nsubjects |> map_df(\(x) make_subject(ntrials = ntrials,
                                            pars = true_params,
                                            subject_no = x)) |>
  mutate(response = factor(response, levels = c("lower", "upper")),
         condition = as_factor(condition),
         ID = as_factor(ID))

participant_params <- d |>
  group_by(ID) |>
  summarize(across(c(a, v1, v2, z, t0), \(x) round(first(x), 3)))

d <- d |> select(ID, condition, rt, response)

# write_csv(d, file = "ddm-data.csv")
# write_csv(participant_params, file = "participant-params.csv")
```



```{r}
#| eval: true
#| echo: false
#| warning: false

library(tidyverse)
library(rtdists)

d <- read_csv("ddm-data.csv")
participant_params <- read_csv("participant-params.csv")

d
```


```{r}
d <- d |> 
  mutate(across(c(ID, condition, response), ~as_factor(.)))

d
```


```{r}
d |>
  filter(ID %in% sample(levels(d$ID), 3)) |>
  ggplot(aes(rt, response, fill = response)) +
  geom_violin() +
  geom_jitter(height = 0.1, alpha = 0.2, size = 0.25) +
  scale_fill_viridis_d(option = "B", direction = 1,
                       begin = 1/2, end = 2/2) +
  xlim(c(0, 1.5)) +
  facet_grid(condition ~ ID)
```



```{r}
summary <- d |> group_by(ID, condition) |> 
  summarise(mean_rt = mean(rt),
            median_rt = median(rt),
            mean_upper = mean(response == "upper"))
```

```{r}
summary |> 
  ggplot(aes(condition, mean_upper)) +
  geom_boxplot()
```


```{r}
diffusionloglik <- function(pars, condition, rt, response) {

  conditions <- levels(condition)
  likelihoods <- vector("numeric", length(rt))

  for (i in seq_along(conditions)) {
        likelihoods <- vector("numeric", length(rt))
        
        likelihoods[condition == conditions[i]] <- 
          # tryCatch(ddiffusion(rt[condition == conditions[i]],
          #                                response = response[condition == conditions[i]],
          #                                a = pars["a"],
          #                                v =  pars[str_c("v", i)],
          #                                t0 = pars["t0"],
          #                                z = pars["z"] * pars["a"],
          #                                s = 1.0),
          #          error = function(e) 0)
                  ddiffusion(rt = rt[condition == conditions[i]],
                             response = response[condition == conditions[i]],
                             a = pars["a"],
                             v =  pars[str_c("v", i)],
                             t0 = pars["t0"],
                             z = pars["z"] * pars["a"],
                             s = 1.0)
  }
  
  if (any(likelihoods == 0)) return(1e6)
  return(-sum(log(likelihoods)))
}
```


```{r}
init_params <- function() {
  params <- c(a = runif(1, 0.8, 1.2),
             z = runif(1, 0.45, 0.55),
             t0 = runif(1, 0.01, 0.3))
 
  # drifts <- sort(abs(rnorm(2)))
  drifts <- sort(runif(2, 0.1, 1.5))
  names(drifts) <- paste0("v", 1:2)

  c(drifts, params)
}
```

```{r}
participants <- levels(d$ID)
n_participants <- length(participants)

# no. parameters (a, v1, v2, z, t0)
n_pars <- length(init_params())

estimates <- array(NA, c(n_participants, n_pars))
colnames(estimates) <- c("a", "v1", "v2", "z", "t0")
rownames(estimates) <- str_c("ID", 1:n_participants, sep = "_")

for (i in seq_along(participants)) {
  participant_data <- filter(d, ID == i)
  
  fit <- nlminb(init_params(),
                diffusionloglik,
                lower = 0,
                condition = participant_data$condition,
                rt = participant_data$rt,
                response = participant_data$response)
    
  estimates[i, ] <- fit$par |> round(3)
}
```

```{r}
estimates |>as_tibble() |>
  mutate(ID = row_number()) |> 
  select(ID, a, v1, v2, z, t0)
```



```{r}
participant_params
```

