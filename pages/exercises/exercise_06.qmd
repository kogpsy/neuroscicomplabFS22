---
title: "√úbung 6"
description: |
  DDM Parameter sch√§tzen.
date: "2022-05-10"
author:
  - name: Andrew Ellis
    url: https://github.com/awellis
    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern
    affiliation-url: https://www.kog.psy.unibe.ch
    orcid: 0000-0002-2788-936X
license: CC BY
citation: true
bibliography: ../../bibliography.bib
format:
    html:
        toc: true
        code-link: true
---
```{r}
#| include: false

# Set working directory of R
knitr::opts_knit$set(root.dir = '../../data/exercise-06')
```

:::{.callout-note}
Die Daten f√ºr diese √úbung finden Sie hier: üëâ [Download Data](../../data/exercise-06/data/ddm-data.csv)

Die Aufgaben, die Sie bearbeiten sollen, finden Sie in einem gelben Kasten. Optionale Aufgaben sind in orangen K√§sten.

In diesem File finden Sie Beispielscode. Manche Zeilen enthalten `___`. Hier m√ºssen Sie den Code vervollst√§ndigen.

Laden Sie bitte Ihre L√∂sung als R Skript bis **Mittwoch, 17.5.2022, um 00:30 Uhr**, in den Order f√ºr √úbung 6 auf ILIAS.


Nennen Sie Ihr File *Matrikelnummer_Nachname_uebung-6.R*.
:::

# Aufgabenstellung

```{r}
#| include: true
#| eval: true
library(tidyverse)
library(rtdists)

true_params <- c(a = 0.8,
                 v = 0.3,
                 z1 = 0.7,
                 z2 = 0.5,
                 t0 = 0.2)

ntrials <- 1e3

make_subject <- function(ntrials = 1e3, pars, subject_no = 1) {

  a <- exp(log(pars["a"]) + rnorm(1, 0, 0.1))
  v <- exp(log(pars["v"]) + rnorm(1, 0, 0.1))
  z1 <- plogis(qlogis(pars["z1"]) + rnorm(1, 0, 0.1))
  z2 <- plogis(qlogis(pars["z2"]) + rnorm(1, 0, 0.1))
  t0 <- exp(log(pars["t0"]) + rnorm(1, 0, 0.1))

  s <- 1.0
  
  d <- as_tibble(bind_rows(
  rdiffusion(ntrials, a = a, v = v, t0 = t0, z = z1*a, s = s) |>
  mutate(condition = "A",
         ID = subject_no),
  rdiffusion(ntrials, a = a, v = v, t0 = t0, z = z2*a, s = s) |>
  mutate(condition = "B",
         ID = subject_no))) |>
  mutate(response = factor(response, levels = c("lower", "upper")),
         condition = as_factor(condition))
  d <- d |> mutate(a = a, v = v, z1 = z1, z2 = z2, t0 = t0)
}

nsubjects <- 6
set.seed(831)

d <- 1:nsubjects |> map_df(\(x) make_subject(ntrials = ntrials,
                                            pars = true_params,
                                            subject_no = x)) |>
  mutate(response = factor(response, levels = c("lower", "upper")),
         condition = as_factor(condition),
         ID = as_factor(ID))

participant_params <- d |>
  group_by(ID) |>
  summarize(a = first(a),
            v = first(v),
            z1 = first(z1),
            z2 = first(z2),
            t0 = first(t0))
d <- d |> select(ID, condition, rt, response)
```



```{r}
#| eval: true
#| echo: false
#| warning: false

d |>
  filter(ID %in% sample(levels(d$ID), 3)) |>
  ggplot(aes(rt, response, fill = response)) +
  geom_violin() +
  geom_jitter(height = 0.1, alpha = 0.2, size = 0.25) +
  scale_fill_viridis_d(option = "B", direction = 1,
                       begin = 1/2, end = 2/2) +
  xlim(c(0, 1.5)) +
  facet_grid(condition ~ ID)
```





```{r}
diffusionloglik <- function(pars, condition, rt, response)
{
  # Return a large number of any of the parameters are negative
  # if (any(pars < 0)) return(1e6 + 1e3 * rnorm(1))

  conditions <- levels(condition)
  likelihoods <- vector("numeric", length(rt))

  for (i in seq_along(conditions)) {
    likelihoods <- c(likelihoods,
                    tryCatch(ddiffusion(rt[condition == conditions[i]],
                                         response = response[condition == conditions[i]],
                                         a = pars["a"],
                                         v = pars["v"],
                                         t0 = pars["t0"],
                                         z = pars[str_c("z", i)] * pars["a"],
                                         sz = pars["sz"],
                                         sv = pars["sv"],
                                         st0 = pars["st0"],
                                         s = 0.1),
                              error = function(e) 0))
  }
  # if any likelihoods are 0, then stop and return an impossibly large number,
  # since the log likelihood should be minimized.
  if (any(likelihoods == 0)) return(1e6 + 1e3 * rnorm(1))
  return(-sum(log(likelihoods)))
}
```


```{r}
# init_params <- function() {
#  params <- c(a = abs(runif(1, 0.1, 0.2)),
#    v = abs(rnorm(1, 0.2, .05)),
#    z1 = abs(rnorm(1, 0.5, 0.2)),
#    z2 = abs(rnorm(1, 0.5, 0.2)),
#    t0 = runif(1, 0.1, 0.3),
#    sz = runif(1, 0, 0.5),
#    sv = runif(1, 0, 0.5),
#    st0 = runif(1, 0, 0.5),
#    d = rnorm(1, 0, 0.05))
#  params
# }
init_params <- function() {
 params <- c(a = abs(rnorm(1, 0.5, 0.1)),
   v = abs(rnorm(1, 0.5, .05)),
   z1 = abs(rnorm(1, 0.5, 0.2)),
   z2 = abs(rnorm(1, 0.5, 0.2)),
   t0 = runif(1, 0.1, 0.3),
   sz = runif(1, 0, 0.5),
   sv = runif(1, 0, 0.5),
   st0 = runif(1, 0, 0.5),
   d = rnorm(1, 0, 0.05))
 params
}
```

```{r}
participants <- levels(d$ID)
n_participants <- length(participants)
# no. parameters (a, v, z1, z2, t0, sz, sv, st0, d)
n_pars <- 9
estimates <- array(NA, c(n_participants, n_pars))
colnames(estimates) <- c("a", "v", "z1", "z2", "t0", "sz", "sv", "st0", "d")
rownames(estimates) <- str_c("ID", 1:n_participants, sep = "_")

for (i in seq_along(participants)) {
  participant <- filter(d, ID == i)
  fit <- optim(init_params(),
             diffusionloglik,
             method = "L-BFGS-B",
             condition = participant$condition,
             rt = participant$rt,
             response = participant$response,
            lower = c(0, 0, 0, 0, 0, 0, 0, 0, -Inf), 
            upper = c(2, 2, 1, 1, 0.5, 1, 1, 0.5, Inf))
  estimates[i, ] <- fit$par |> round(3)
}
```

```{r}
estimates[, 1:5]
```



```{r}
participant_params
```
